// pleiades.cpp --- git based k-means clustering
// Copyright (C) 2011  Tim Harder, Thomas Hamelryck, Wouter Boomsma
//
// This file is part of Phaistos
//
// Phaistos is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Phaistos is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Phaistos.  If not, see <http://www.gnu.org/licenses/>.
//

#include "cluster_git.h"
#include "git.h"
#include "git_element.h"
#include "pleiades_options.h"

#include <stdio.h>
#include <string>
#include <cstring>
#include <math.h>
#include <stdlib.h>
#include <vector>
#include <iostream>	
#include <fstream>
#include <limits>
#include <algorithm>

#include "protein/chain_ca.h"
#include "protein/chain_fb.h"
#include "protein/chain.h"

#ifdef PHAISTOS_VERSION
#ifdef SVN_REVISION
#include "revision.h"
#endif
#endif

#include "utils/vector_matrix_3d.h"

#ifdef HAVE_MUNINNLIB
#include "muninn/tools/CanonicalAveragerFromStatisticsLog.h"
#endif

#define CHAR_STAR_CONTAINER_SIZE 20000 // quick hack to host long strings without snprintf
using namespace phaistos;

//! Reads GIT vectors from a file. Different formats generated by different conversion
//! methods are matched automatically.
//!
//! \param options Pleiades runtime options
//! \param filename file to be parsed
//! \param my_git_vec Vector reference to store the found vectors in
//! \param energies vector reference to return the energies extracted from the git filename (empty if no energies were found)
void read_file(PleiadesOptions &options, const char* filename, std::vector<GitElement> &my_git_vec, std::vector<double> &energies) {

     // Variables to read the lines
     char c_name[CHAR_STAR_CONTAINER_SIZE], *pc_name = new char[CHAR_STAR_CONTAINER_SIZE], *dummy_chain = new char[10];
     int domain = 0, chain = 0, index = 0, length = 0;
     double my_vec[31];
     std::string *tmp_name;
     tmp_name = new std::string("");

     GitElement *my_git = NULL;

     // initialize the values
     for (int i = 0; i < 31; i++) {
          my_vec[i] = 0;
     }

     std::ifstream ifs(filename);
     if (ifs.fail()) {
          std::cout << "Error reading " << filename << "\n";
          exit(1);
     }
     std::string temp;
     int skipper = 0;
     while (getline(ifs, temp)) {

          //scan it for the values (format as produced by the original git program)
          int dummy = 0;
          int r_value = sscanf(temp.c_str(),
                    "%s %s %d %d %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le",
                    pc_name, dummy_chain, &dummy, &length, &my_vec[0], &my_vec[1], &my_vec[2], &my_vec[3], &my_vec[4], &my_vec[5], &my_vec[6], &my_vec[7], &my_vec[8],
                    &my_vec[9], &my_vec[10], &my_vec[11], &my_vec[12], &my_vec[13], &my_vec[14], &my_vec[15], &my_vec[16], &my_vec[17], &my_vec[18], &my_vec[19],
                    &my_vec[20], &my_vec[21], &my_vec[22], &my_vec[23], &my_vec[24], &my_vec[25], &my_vec[26], &my_vec[27], &my_vec[28], &my_vec[29], &my_vec[30]);

          // Check whether values were read
          if (r_value < 35) {

               // If first read fails, try a different format
               dummy = 0; // dummy
               int r_value = sscanf(temp.c_str(),
                                    "%s %d %d %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le",
                                    pc_name, &dummy, &length, &my_vec[0], &my_vec[1], &my_vec[2], &my_vec[3], &my_vec[4], &my_vec[5], &my_vec[6],
                                    &my_vec[7], &my_vec[8], &my_vec[9], &my_vec[10], &my_vec[11], &my_vec[12], &my_vec[13], &my_vec[14], &my_vec[15],
                                    &my_vec[16], &my_vec[17], &my_vec[18], &my_vec[19], &my_vec[20], &my_vec[21], &my_vec[22], &my_vec[23], &my_vec[24],
                                    &my_vec[25], &my_vec[26], &my_vec[27], &my_vec[28], &my_vec[29], &my_vec[30]);

               if (true || r_value < 34) {
                    // if it failed again, try yet another format (this is this one dumped by phaistos.cpp)
                    dummy = 0; // dummy
                    int r_value = sscanf(temp.c_str(),
                                         "%s %d %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le %le",
                                         pc_name, &length, &my_vec[0], &my_vec[1], &my_vec[2], &my_vec[3], &my_vec[4], &my_vec[5], &my_vec[6], &my_vec[7],
                                         &my_vec[8], &my_vec[9], &my_vec[10], &my_vec[11], &my_vec[12], &my_vec[13], &my_vec[14], &my_vec[15], &my_vec[16],
                                         &my_vec[17], &my_vec[18], &my_vec[19], &my_vec[20], &my_vec[21], &my_vec[22], &my_vec[23], &my_vec[24], &my_vec[25],
                                         &my_vec[26], &my_vec[27], &my_vec[28], &my_vec[29], &my_vec[30]);
                    if (r_value < 33) {
                         continue;
                    }
               }
          }
          sprintf(c_name, "%s", pc_name);

          if (false && (length < 50 || length > 700 || dummy != 0)) {
               if (options.debug)
                    std::cout << "# Error in input line. Possibly a length mismatch: (len:" << length << ") \n# " << temp << "\n";
               skipper++;
               continue;
          }
          bool off = false;
          for (int i = 0; i < 31; i++) {
               if (my_vec[i] > 1000 || my_vec[i] < -1000) {
                    off = true;
                    break;
               }
          }

          if (off) {
               skipper++;
               continue;
          }

          if (options.w_k_means || options.evaluate_clusters_weighted) {
               // if we want to do weighted k-means, we try
               // to extract the energy from the filename as well
               tmp_name = new std::string(c_name);
               int end = -1, start = -1;
               if (tmp_name->compare(tmp_name->size() - 1, 1, "b") != 0) {
                    end = tmp_name->size() - 1;
               }
               for (int i = tmp_name->size() - 1; i > 0; i--) {
                    if (tmp_name->compare(i, 1, ".") == 0 && end < 0) {
                         end = i;
                    }
                    if (tmp_name->compare(i, 1, "_") == 0 && start < 0) {
                         start = i + 1;
                         break;
                    }
               }

               // if we had trouble reading the energies .. just continue
               if (start > 0 && end > 0) {
                    energies.push_back(atof(tmp_name->substr(start, end - start).c_str()));
                    if (options.debug) {
                         std::cout << *tmp_name << "  e= " << tmp_name->substr(start, end - start) << "\n";
                    }
               } else {
                    std::cout << "Warning could not determine energy for " << tmp_name << " using dummy value instead.\n";
                    energies.push_back(0);
               }
          }
          // Transfer the array to a vector
          my_git = new GitElement;

          (*my_git).set_name(c_name);
          (*my_git).set_chain(chain);
          (*my_git).set_index(index);
          (*my_git).set_domain(domain);
          (*my_git).set_length(length);
          (*my_git).set_git(my_vec);

          my_git_vec.push_back((*my_git));
          index++;
     }

     if (options.verbose && skipper != 0)
          std::cout << "# Skipped over a couple of lines .. " << skipper << " lines in total.\n";

     ifs.close();
     delete my_git;
     delete pc_name;
     delete dummy_chain;
     delete tmp_name;

     return;
}

//! create a vector of cummulative probabilities, normalized to [0,1]
//!
//! \param probabilities vector containing the probabilities.
//! \param cum_probabilities vector reference to return the cumulative array.
void sum_probabilities(std::vector<double> &probabilities, std::vector<double> &cum_probabilities) {

     int len = probabilities.size();
     cum_probabilities.clear();
     cum_probabilities.resize(len);

     cum_probabilities[0] = probabilities[0];
     for (int i = 1; i < len; i++) {
          cum_probabilities[i] = cum_probabilities[i - 1] + probabilities[i];
     }

     double normal = cum_probabilities[len - 1];
     for (int i = 0; i < len; i++) {
          cum_probabilities[i] /= normal;
     }
}

//! Select a random cluster center with a certain probability.
//!
//! \param cum_probabilities cumulative probability array in the interval [0,1]
int random_cluster(std::vector<double> &cum_probabilities) {

     // find a random double
     double rnd = rand() / (float(RAND_MAX) + 1);

     for (int i = 0; i < (int) cum_probabilities.size(); i++) {
          if (rnd < cum_probabilities[i]) {
               return i;
          }
     }

     return 0;
}

//! Guess a good number of k clusters given a distance threshold.
//!
//! \param options Pleiades runtime options
//! \param my_git_vec vector containing all the GIT vectors to be clusters.
//! \param clusters vector reference to return the found clusters.
void guess_k(PleiadesOptions &options, std::vector<GitElement> &my_git_vec, 
             std::vector<Cluster> &clusters) {

     int len = my_git_vec.size();
     double dist;
     int cluster_id = 0;
     bool is_stored;
     Cluster *tmp = NULL;
     double cutoff = options.guess_k_threshold;
     int opt_cluster = 10;
     double threshold = 10;

     // Assign all the points to the clusters again.
     for (int k = 0; k < opt_cluster; k++) {

          if (options.verbose)
               printf("Calculating near cluster [%2d / %2d]\n", k + 1, opt_cluster);

          for (int i = 0; i < len; i++) {
               is_stored = false;

               for (unsigned int j = 0; j < clusters.size(); j++) {
                    dist = get_git_distance(my_git_vec[i].get_git(), clusters[j].get_mean().get_git());
                    if (dist < cutoff) {
                         //printf("%s added to cluster %d (%d)\n", myGitVec[i].get_name().c_str(), clusters[j].get_id(), clusters[j].get_density());
                         is_stored = true;
                         clusters[j].add_member(my_git_vec[i]);
                         break;
                    }
               }
               if (!is_stored) {
                    //printf("created new cluster %d\n", clusterID);
                    tmp = new Cluster(++cluster_id);
                    (*tmp).add_member(my_git_vec[i]);
                    //printf("%d \n" , clusters.size());
                    clusters.push_back((*tmp));
                    //printf("%d \n" , clusters.size());
               }
          }

          // Get rid of the mini or empty clusters.
          for (unsigned int i = 0; i < clusters.size(); i++) {
               // keep all clusters in the last iteration
               //if (clusters[i].get_size() < threshold) {
               if (clusters[i].get_density() < threshold) {
                    clusters.erase(clusters.begin() + i);
                    i--;
               }
          }
     }
     delete tmp;
}

//! Output a header block containing the most important runtime variables.
//!
//! \param options Pleiades runtime options.
//! \param o output stream to write to.
void output_header(PleiadesOptions options, std::ofstream &o) {
     o << "############################################################" << std::endl;
     o << "#\t" << std::endl;
     o << "#\toutput generated by PLEIADES	" << std::endl;
     o << "#\t" << std::endl;
     o << "#\tParameters used for the run" << std::endl;
     o << "#\t" << std::endl;
     o << "#\tinput file :\t" << options.git_file.c_str() << std::endl;
     o << "#\titerations :\t" << options.iterations << std::endl;
     o << "#\tK :\t\t" << options.k << std::endl;
     o << "#\t" << std::endl;
     o << "############################################################\n";
}

//! Output a vector of clusters. If the long_output runtime option has been
//! set, all member of the cluster will be written to the given stream,
//! otherwise, only the five members closest to the centroid are written.
//!
//! \param options Pleiades runtime options.
//! \param clusters vector of clusters.
//! \param o output stream to write to.
void output_cluster(PleiadesOptions options, std::vector<Cluster> &clusters, std::ofstream &o) {

     std::sort(clusters.begin(), clusters.end(), std::greater<Cluster>());
     output_header(options, o);
     ChainCA *native = NULL;
     if (options.rmsd_native_pdb != "" && file_exists(options.rmsd_native_pdb.c_str())) {
          native = new ChainCA(options.rmsd_native_pdb.c_str());
     }
     char tmp[1000];
     for (unsigned int i = 0; i < clusters.size(); i++) {
          //fprintf(stderr, "############################################################\n");
          sprintf(tmp, "[Cluster %4d (size: %5d, sd: %10.4f, dens: %10.4f ) ]", (clusters[i]).get_id(), (clusters[i]).get_size(), (clusters[i]).get_std_dev(),
                    (clusters[i]).get_density());
          o << tmp << std::endl;
          printf("%010.4f -> Cluster %4d (size: %5d, sd: %10.4f, dens: %10.4f \t%s)\n", (clusters[i]).get_density(), (clusters[i]).get_id(),
                    (clusters[i]).get_size(), (clusters[i]).get_std_dev(), (clusters[i]).get_density(), (clusters[i]).get_median().get_name().c_str());

          if (options.long_output) {
               (clusters[i]).dump_member_list(o, -1, native, options.rmsd_decoy_prefix);
          } else {
               (clusters[i]).dump_member_list(o, 5, native, options.rmsd_decoy_prefix);
          }
     }

     if (native != NULL)
          delete native;

     printf("\n");
}

//! Perform the actual k-means clustering on a set of GIT vectors.
//!
//! \param my_k number of cluster centers k
//! \param options Pleiades runtime options
//! \param my_git_vec vector of GIT vectors
//! \param clusters vector reference to return the found cluster
//! \param weights vector of weights for weighted k-means clustering.
void k_means(int my_k, PleiadesOptions &options, std::vector<GitElement> &my_git_vec, 
             std::vector<Cluster> &clusters, std::vector<double> *weights = NULL) {

     if (options.debug && weights == NULL) {
          std::cout << "D> K-mean setup. \n";
          std::cout << std::flush;
     } else if (options.debug) {
          std::cout << "D> weighted K-mean setup. \n";
          std::cout << std::flush;
     }

     if (weights != NULL) {
          // weighted clustering
          assert(my_git_vec.size() == weights->size());

          // Add the weights to the GIT elements here
          for (int i = 0; i < (int) my_git_vec.size(); i++) {
               my_git_vec[i].set_weight(weights->at(i));
          }
     } else {
          for (int i = 0; i < (int) my_git_vec.size(); i++) {
               my_git_vec[i].set_weight(1.);
          }
     }

     int k = my_k;
     int iterations = options.iterations;

     int len = my_git_vec.size();
     double dist;
     int cluster_id = 0;
     Cluster *tmp = NULL;

     if (options.debug) {
          std::cout << "D> Setting up initial K cluster ... ";
          std::cout << std::flush;
     }

     if (k != (int) clusters.size() && options.smart_seed) {
          if (options.verbose)
               std::cout << "Using smart seeding.\n";
          // not enough cluster center yet. Add additional random ones
          std::random_shuffle(my_git_vec.begin(), my_git_vec.end());
          clusters.clear();

          // try k-means++ initial seeding here
          // select first cluster at random
          tmp = new Cluster(++cluster_id);
          (*tmp).add_member(my_git_vec[0]);
          clusters.push_back((*tmp));

          std::vector<double> ll;
          ll.resize(len);

          // and fill k in
          // for every cluster
          for (int i = 1; i < k; i++) {
               // calculate the minimum distance from
               // every point to the nearest existing cluster
               for (int i = 0; i < len; i++) {
                    double min_d = 99999999;

                    for (unsigned int j = 0; j < clusters.size(); j++) {
                         dist = get_git_distance(my_git_vec[i].get_git(), ((clusters[j]).get_mean()).get_git());
                         if (dist < min_d) {
                              min_d = dist;
                         }
                    }
                    ll[i] = min_d * min_d;
               }

               std::vector<double> cum_probabilities;
               sum_probabilities(ll, cum_probabilities);
               int index = random_cluster(cum_probabilities);
               //
               tmp = new Cluster(++cluster_id);
               (*tmp).add_member(my_git_vec[index]);
               clusters.push_back((*tmp));
          }
     } else if (k != (int) clusters.size()) {

          // not enough cluster center yet. Add additional random ones
          std::random_shuffle(my_git_vec.begin(), my_git_vec.end());
          clusters.clear();
          // and fill k in
          for (int i = 0; i < k; i++) {
               tmp = new Cluster(++cluster_id);
               (*tmp).add_member(my_git_vec[i]);
               clusters.push_back((*tmp));
          }

     }

     if (options.debug)
          std::cout << "done (K= " << clusters.size() << ")\n";

     for (int l = 0; l < iterations; l++) {

          if (options.verbose)
               printf("Calculating Kmeans cluster (with k = %d) [%2d / %2d]\n", (int) clusters.size(), l + 1, iterations);

          // shuffle the order
          std::random_shuffle(my_git_vec.begin(), my_git_vec.end());

          // loop over all clusters and free their members
          // only interesting in the later rounds.
          for (unsigned int i = 0; i < clusters.size(); i++) {
               clusters[i].free_members();
          }

          // assign all the points to the clusters again.
          for (int i = 0; i < len; i++) {
               double min_d = 9999999.;
               int best_cluster = -1;

               for (unsigned int j = 0; j < clusters.size(); j++) {
                    dist = get_git_distance(my_git_vec[i].get_git(), ((clusters[j]).get_mean()).get_git());
                    if (dist < min_d) {
                         best_cluster = j;
                         min_d = dist;
                    }
               }

               if (best_cluster >= 0 && best_cluster < (signed int) clusters.size()) {
                    clusters[best_cluster].add_member(my_git_vec[i], false);
               }
          }

          // and recalculate mean centeroids
          bool converged = true;
          for (unsigned int i = 0; i < clusters.size(); i++) {
               // returns true upon convergences
               if (not clusters[i].calc_mean())
                    converged = false;
          }

          if (converged) {
               if (options.verbose)
                    std::cout << "Convergences detected .. stopping\n";
               break;
          }

     }
     delete tmp;
}

//! Pleiades main
//! \param argc commandline argument number
//! \param argv commandline argument value
int main(int argc, char *argv[]) {

     PleiadesOptions options(argc, argv);

     if (options.verbose) {
          printf("\n######################################################################################################\n");
          std::cout << "#     __________.__         .__            .___                              " << std::endl;
          std::cout << "#     \\______   \\  |   ____ |__|____     __| _/____   ______               " << std::endl;
          std::cout << "#      |     ___/  | _/ __ \\|  \\__  \\   / __ |/ __ \\ /  ___/                   " << std::endl;
          std::cout << "#      |    |   |  |_\\  ___/|  |/ __ \\_/ /_/ \\  ___/ \\___ \\    " << std::endl;
          std::cout << "#      |____|   |____/\\___  >__(____  /\\____ |\\___  >____  >                    " << std::endl;
          std::cout << "#                         \\/        \\/      \\/    \\/     \\/  " << std::endl << "#"<< std::endl;
#ifdef PHAISTOS_VERSION
#ifdef SVN_REVISION
          printf("#                                Version: %5s  Build: %5s \n", PHAISTOS_VERSION, SVN_REVISION);
#endif
#endif
          printf("######################################################################################################\n");
     }

     uint now = (uint) time(NULL);
     if (options.verbose) {
          std::cout << "Seed: " << now << "\n";
          std::cout << "RAND_MAX " << RAND_MAX << "\n";
     }

     srand(now);

     if (options.git_file == "") {
          options.print_usage();
          return 0;
     }

     if (options.debug)
          options.verbose = true;

     // getting the contents
     std::vector<GitElement> my_git_vec;
     std::vector<Cluster> clusters;
     std::vector<double> energies;

     // Parse input file
     if (options.debug)
          std::cout << "D> Reading the input file ... ";
     read_file(options, options.git_file.c_str(), my_git_vec, energies);
     if (options.debug)
          std::cout << "done (read " << my_git_vec.size() << " vectors) \n";
     if (options.verbose)
          std::cout << "Done reading file " << options.git_file << " - Found " << my_git_vec.size() << " vectors. \n";

     // Check whether parsing worked
     if (not my_git_vec.size()) {
          std::cerr << "ERROR: The input file could not be read. Please make sure you refered to a valid git vector file.\n\n";
          return 256;
     }

     int my_k = options.k;
     // open an output stream
     std::ofstream out_file(options.out_file.c_str());

     // are we asked to guesstimate K?
     if (options.guess_k) {
          if (options.verbose)
               std::cout << "Trying to estimate K.\n";
          guess_k(options, my_git_vec, clusters);
          my_k = clusters.size();
          std::cout << "Using a threshold of " << options.guess_k_threshold << " k was estimated to be " << my_k << "\n";
     }

     if (my_k >= (int) my_git_vec.size()) {
          std::cerr << "WARNING: You tried calculating k=" << my_k << " cluster but only have " << my_git_vec.size() << " input vectors.\n\n";
          return 256;
     }
     // do we want to run a real k-means
     if (options.k_means) {
          if (options.verbose)
               std::cout << "Starting K-Means (K=" << my_k << ")\n";

          // do the limbo
          k_means(my_k, options, my_git_vec, clusters);
          
     }

     if (options.w_k_means || options.evaluate_clusters_weighted) {

          std::vector<double> weights;

#ifdef HAVE_MUNINNLIB

          if (options.muninn_log != "" && energies.size() == my_git_vec.size()) {

               if (options.verbose)
                    std::cout << "Starting weighted K-Means (K=" << my_k << ", beta=" << options.beta << ")\n";
               // now we need to read in the histograms
               // and have muninn calculate the correct weights from the histograms
               if (options.debug)
                    std::cout << "Reading Muninn Weights from: " << std::string(options.muninn_log).c_str() << "\n";
               Muninn::CanonicalAveragerFromStatisticsLog averager = Muninn::CanonicalAveragerFromStatisticsLog(options.muninn_log);
               weights = averager.calc_weights(energies, options.beta);

               double max = -std::numeric_limits<double>::infinity();
               double min = std::numeric_limits<double>::infinity();
               int zeros = 0;
               for (int k = 0; k < (int) weights.size(); k++) {
                    if (weights[k] > max)
                         max = weights[k];
                    if (weights[k] < min && weights[k] != 0)
                         min = weights[k];
                    if (weights[k] == 0)
                         zeros++;
               }

               if (options.scale_weights) {
                    double factor = 1 / max;
                    for (int k = 0; k < (int) weights.size(); k++) {
                         if (weights[k] == 0)
                              weights[k] = min;
                         weights[k] = weights[k] * factor;
                    }
               } else if (zeros) {
                    std::cout << std::endl << std::endl << "WARNING: Performing weighted clustering and found " << zeros
                              << " structures with weight zero.\nWARNING: This usually leads to weird results .. proceed with caution or enable scaling (--scale-weights). "
                              << std::endl << std::endl << std::endl;
               }

          } else 
#endif
          if (energies.size() == my_git_vec.size()) {
               if (options.verbose)
                    std::cout << "Starting weighted K-Means (ab)using energies as weights (K=" << my_k << ", beta=" << options.beta << " [scaling factor])"
                              << std::endl;
               for (int k = 0; k < (int) energies.size(); k++) {
                    weights.push_back(energies[k] * options.beta);
               }
          } else {
               std::cerr << "ERROR: Requested weighted clustering, but no weights were set!" << std::endl;
               return 256;
          }
          if (options.w_k_means) {
              k_means(my_k, options, my_git_vec, clusters, &weights);
          }
          //Evaluate clusters weighted:
          if (options.evaluate_clusters_weighted && !options.w_k_means) {
               // weighted clustering
               assert(my_git_vec.size() == weights.size());

               for (unsigned int i = 0; i < clusters.size(); i++) {
                    clusters[i].set_weights_of_members(weights);
                    clusters[i].calc_mean();
               }
          }
     }
     
     // put out ..
     output_cluster(options, clusters, out_file);
     
     std::cout << "\n";

     out_file.close();
     return 0;
}

